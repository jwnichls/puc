/* Control Point Main Module */

/**
 * NOTE TO PUC IMPLEMENTORS:
 *
 * This is the file which has been modified to provide support for interaction between the code
 * generated by Intel Authoring Tools and the Java PUC Device code.  Primarily, the functions
 * with JNI-type names have been added; there are also a number of utilities which were added,
 * including the command queueing structure and methods, the JNI environment storage structure
 * and methods, and all other methods which do not begin with "UPnP" or "Java_".
 *
 * The header file LightControl.h also has modifications, such as the JNI method headers.
 */

#include <jni.h>
#include "LightControl.h"
#include <stdio.h>

#ifndef MICROSTACK_NO_STDAFX
#include "stdafx.h"
#endif
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include "UPnPControlPoint.h"
#include "ILibParsers.h"

// Generated variables for UPnP stack
void *UPnP_CP;
void *UPnP_CP_chain;

// Variable to check if the control point is currently running (i.e. capable of accepting commands)
int running;

/**
 * Stored background thread JNIEnv and UPnPControl pointers
 *
 * NOTE: These pointers are only good in the background thread (i.e., the one started by nativeStartCP).
 * Using them in any other thread will have unpredictable (but probably very bad) results.  The reason
 * for storing these pointer globally is so that they may be used by the event queuing methods to construct
 * and enqueue java-side UPnPEvents.
 */
struct {
	JNIEnv *bgEnv;
	jobject bgControl;
	jclass stateChangeCls;
	jmethodID stateChangeCtorMid;
	jclass factoryEventCls;
	jmethodID createFoundMid;
	jmethodID createRemovedMid;
	jclass controlCls;
	jmethodID addEventMid;
} JNIData;

void fillJNIData(JNIEnv *env, jobject obj)
{
	JNIData.bgEnv = env;
	JNIData.bgControl = obj;
	JNIData.stateChangeCls = (*env)->FindClass(env, "edu/cmu/hcii/puc/devices/UPnP/UPnPEvent$StateChange");
	JNIData.stateChangeCtorMid = (*env)->GetMethodID(env, JNIData.stateChangeCls, "<init>",
		"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
	JNIData.factoryEventCls = (*env)->FindClass(env, "edu/cmu/hcii/puc/devices/UPnP/UPnPEvent$FactoryEvent");
	JNIData.createFoundMid = (*env)->GetStaticMethodID(env, JNIData.factoryEventCls, "createFoundEvent",
		"(Ljava/lang/String;Ljava/lang/String;)Ledu/cmu/hcii/puc/devices/UPnP/UPnPEvent$FactoryEvent;");
	JNIData.createRemovedMid = (*env)->GetStaticMethodID(env, JNIData.factoryEventCls, "createRemovedEvent",
		"(Ljava/lang/String;)Ledu/cmu/hcii/puc/devices/UPnP/UPnPEvent$FactoryEvent;");
	JNIData.controlCls = (*env)->GetObjectClass(env, obj);
	JNIData.addEventMid = (*env)->GetMethodID(env, JNIData.controlCls, "addEvent",
		"(Ledu/cmu/hcii/puc/devices/UPnP/UPnPEvent;)V");
}

void clearJNIData()
{
	memset(&JNIData, 0, sizeof(JNIData));
}

/**
 * Device List Definition and Manipulating Functions
 *
 * A list of devices is maintained at all times.  Each element in the list contains pointers to the
 * UPnPDevice object, its powerService, and its dimmingService.  The device object contains a pointer
 * to a UDN (unique device name?), a 128-bit string which uniquely identifies the device on the network.
 * The get and remove methods use this string to search the list of devices.
 *
 * The add and remove functions also handle communication with the LightFactory java class, by constructing
 * and sending the necessary UPnPEvent.FactoryEvent events to the LightControl's event queue.  To
 * understand how this works, a thorough understanding of JNI is necessary.  There is a large amount of
 * JNI documentation available at the Java website, java.sun.com.
 */

typedef struct DeviceListEntry {
	struct UPnPDevice *device;
	struct UPnPService *powerService;
	struct UPnPService *dimmingService;
	struct DeviceListEntry *next;
} deviceListEntry;

deviceListEntry *listHead;

void addDevice(struct UPnPDevice *device)
{
	jstring jsUDN;
	jstring friendlyName;
	jobject factoryEvt;

	deviceListEntry *newEntry = (deviceListEntry *) malloc(sizeof(deviceListEntry));
	newEntry->device = device;
	newEntry->powerService = UPnPGetService_SwitchPower(device);
	newEntry->dimmingService = UPnPGetService_DimmingService(device);
	newEntry->next = listHead;
	listHead = newEntry;

	jsUDN = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, device->UDN);
	friendlyName = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, device->FriendlyName);

	factoryEvt = (*JNIData.bgEnv)->CallStaticObjectMethod(JNIData.bgEnv, JNIData.factoryEventCls,
		JNIData.createFoundMid, jsUDN, friendlyName);
	(*JNIData.bgEnv)->CallVoidMethod(JNIData.bgEnv, JNIData.bgControl, JNIData.addEventMid,
		factoryEvt);
}

deviceListEntry *getDevice(const char *UDN)
{
	deviceListEntry *temp = listHead;
	while (temp != NULL && (strcmp(UDN, temp->device->UDN) != 0)) temp = temp->next;
	return temp;
}

void removeDevice(const char *UDN)
{
	jstring jsUDN;
	jobject factoryEvt;
	struct UPnPDevice *device = NULL;

	deviceListEntry *temp = listHead;
	if (temp == NULL) return;
	else if (strcmp(UDN, temp->device->UDN) == 0)
	{
		device = temp->device;
		listHead = temp->next;
		free(temp);
	}
	else
	{
		while ((temp->next != NULL) && (strcmp(UDN, temp->next->device->UDN) != 0)) 
			temp = temp->next;
		if (temp->next != NULL)
		{
			deviceListEntry *next = temp->next;
			device = temp->next->device;
			temp->next = temp->next->next;
			free(next);
		}
	}

	if (device != NULL)
	{
		jsUDN = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, device->UDN);

		factoryEvt = (*JNIData.bgEnv)->CallStaticObjectMethod(JNIData.bgEnv, JNIData.factoryEventCls,
			JNIData.createRemovedMid, jsUDN);
		(*JNIData.bgEnv)->CallVoidMethod(JNIData.bgEnv, JNIData.bgControl, JNIData.addEventMid,
			factoryEvt);
	}
}

void cleanList()
{
	deviceListEntry *temp = listHead;
	while (temp != NULL)
	{
		deviceListEntry *next = temp->next;
		free(temp);
		temp = next;
	}
	listHead = NULL;
}

/**
 * Event Handling
 *
 * These methods construct UPnPEvent java object using JNI, and then add them to the corresponding
 * UPnPControl java object's event queue.  To understand exactly how these methods work, a
 * thorough understanding of JNI is required.  There are good resources for JNI on the Java website,
 * java.sun.com.
 */

void addPowerEvent(char *UDN, int newPower)
{
	if (running)
	{
		jstring jsUDN;
		jstring state;
		jstring value;
		jobject powerEvt;

		jsUDN = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, UDN);
		state = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, "Power");
		value = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, (newPower? "True" : "False"));

		powerEvt = (*JNIData.bgEnv)->NewObject(JNIData.bgEnv, JNIData.stateChangeCls,
			JNIData.stateChangeCtorMid, jsUDN, state, value);
		(*JNIData.bgEnv)->CallVoidMethod(JNIData.bgEnv, JNIData.bgControl, JNIData.addEventMid,
			powerEvt);
	}
}

void addLoadLevelEvent(char *UDN, int newLoadLevel)
{
	if (running)
	{
		jstring jsUDN;
		jstring state;
		char valueBuf[4];
		jstring value;
		jobject loadLevelEvt;

		jsUDN = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, UDN);
		state = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, "LoadLevel");
		itoa(newLoadLevel, valueBuf, 10);
		value = (*JNIData.bgEnv)->NewStringUTF(JNIData.bgEnv, valueBuf);

		loadLevelEvt = (*JNIData.bgEnv)->NewObject(JNIData.bgEnv, JNIData.stateChangeCls,
			JNIData.stateChangeCtorMid, jsUDN, state, value);
		(*JNIData.bgEnv)->CallVoidMethod(JNIData.bgEnv, JNIData.bgControl, JNIData.addEventMid,
			loadLevelEvt);
	}
}

// UPnP Event and Response Sinks

/**
 * NOTE:
 *
 * There is currently no error checking implemented here.  To make a fully robust solution, a means
 * should be derived to convey errors through the event queue.
 */

void UPnPResponseSink_SwitchPower_GetStatus(struct UPnPService* Service,int ErrorCode,void *User,int ResultStatus)
{
	addPowerEvent(Service->Parent->UDN, ResultStatus);
}

void UPnPResponseSink_SwitchPower_SetTarget(struct UPnPService* Service,int ErrorCode,void *User)
{
}

void UPnPResponseSink_DimmingService_GetLoadLevelStatus(struct UPnPService* Service,int ErrorCode,void *User,unsigned char RetLoadLevelStatus)
{
	addLoadLevelEvent(Service->Parent->UDN, RetLoadLevelStatus);
}

void UPnPResponseSink_DimmingService_GetMinLevel(struct UPnPService* Service,int ErrorCode,void *User,unsigned char MinLevel)
{
	printf("UPnP Invoke Response: DimmingService/GetMinLevel[ErrorCode:%d](%u)\r\n",ErrorCode,MinLevel);
}

void UPnPResponseSink_DimmingService_SetLoadLevelTarget(struct UPnPService* Service,int ErrorCode,void *User)
{
}

void UPnPEventSink_SwitchPower_Status(struct UPnPService* Service,int Status)
{
	addPowerEvent(Service->Parent->UDN, Status);
}

void UPnPEventSink_DimmingService_LoadLevelStatus(struct UPnPService* Service,unsigned char LoadLevelStatus)
{
	addLoadLevelEvent(Service->Parent->UDN, LoadLevelStatus);
}

/* Called whenever a new device on the correct type is discovered */
void UPnPDeviceDiscoverSink(struct UPnPDevice *device)
{
	struct UPnPDevice *tempDevice = device;
	struct UPnPService *tempService;
	

	addDevice(device);
	
	/* Subscribe for events on all services */
	while(tempDevice!=NULL)
	{
		tempService = tempDevice->Services;
		while(tempService!=NULL)
		{
			UPnPSubscribeForUPnPEvents(tempService,NULL);
			tempService = tempService->Next;
		}
		tempDevice = tempDevice->Next;
	}
}

/* Called whenever a discovered device was removed from the network */
void UPnPDeviceRemoveSink(struct UPnPDevice *device)
{
	removeDevice(device->UDN);
}

// Java native implementations

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeInit
 * Signature: ()V
 *
 * Initializes the native code; should be called exactly once, before any other code in the dll is
 * executed.
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeInit
  (JNIEnv *env, jobject obj)
{
	/* Event callback function registration code */
	UPnPEventCallback_SwitchPower_Status=&UPnPEventSink_SwitchPower_Status;
	UPnPEventCallback_DimmingService_LoadLevelStatus=&UPnPEventSink_DimmingService_LoadLevelStatus;

	listHead = NULL;
	running = 0;
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeStartCP
 * Signature: ()V
 *
 * Starts the control point, so that incoming commands may be processed
 */

JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeStartCP
  (JNIEnv *env, jobject obj)
{	
	UPnP_CP_chain = ILibCreateChain();
	UPnP_CP = UPnPCreateControlPoint(UPnP_CP_chain,&UPnPDeviceDiscoverSink,&UPnPDeviceRemoveSink);

	cleanList();
	fillJNIData(env, obj);

	running = 1;
	printf("PUC Light Control Point 1.0 Started\r\n");
	ILibStartChain(UPnP_CP_chain);
	printf("PUC Light Control Point 1.0 Stopped\r\n");
	running = 0;

	clearJNIData();
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeStopCP
 * Signature: ()V
 *
 * Stops the control point
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeStopCP
  (JNIEnv *env, jobject obj)
{
	if (running)
		ILibStopChain(UPnP_CP_chain);

}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeGetPower
 * Signature: ()Z
 *
 * Sends a request to get the state of the power variable
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeGetPower
  (JNIEnv *env, jobject obj, jstring jsUDN)
{
	deviceListEntry *dev;
	const char *udn = (*env)->GetStringUTFChars(env, jsUDN, 0);

	dev = getDevice(udn);
	if (running && dev->powerService != NULL)
		UPnPInvoke_SwitchPower_GetStatus(dev->powerService, &UPnPResponseSink_SwitchPower_GetStatus, 
			(void *)GET_RESPONSE);

	(*env)->ReleaseStringUTFChars(env, jsUDN, udn); 
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeSetPower
 * Signature: (Z)V
 *
 * Sends a request to set the power variable to on or off (based on newPower)
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeSetPower
  (JNIEnv *env, jobject obj, jstring jsUDN, jboolean newPower)
{
	deviceListEntry *dev;
	const char *udn = (*env)->GetStringUTFChars(env, jsUDN, 0);

	dev = getDevice(udn);
	if (running && dev->powerService != NULL)
		UPnPInvoke_SwitchPower_SetTarget(dev->powerService, &UPnPResponseSink_SwitchPower_SetTarget, 
			(void *)GET_RESPONSE, (int)newPower);

	(*env)->ReleaseStringUTFChars(env, jsUDN, udn); 
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeGetLoadLevel
 * Signature: ()I
 *
 * Sends a request to get the state of the LoadLevel variable
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeGetLoadLevel
  (JNIEnv *env, jobject obj, jstring jsUDN)
{
	deviceListEntry *dev;
	const char *udn = (*env)->GetStringUTFChars(env, jsUDN, 0);

	dev = getDevice(udn);
	if (running && dev->dimmingService != NULL)
		UPnPInvoke_DimmingService_GetLoadLevelStatus(dev->dimmingService, 
			&UPnPResponseSink_DimmingService_GetLoadLevelStatus, (void *)GET_RESPONSE);

	(*env)->ReleaseStringUTFChars(env, jsUDN, udn); 
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeSetLoadLevel
 * Signature: (I)V
 *
 * Sends a request to set the LoadLevel variable to newLoadLevel
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeSetLoadLevel
  (JNIEnv *env, jobject obj, jstring jsUDN, jint newLoadLevel)
{
	deviceListEntry *dev;
	const char *udn = (*env)->GetStringUTFChars(env, jsUDN, 0);

	dev = getDevice(udn);
	if (running && dev->dimmingService != NULL)
		UPnPInvoke_DimmingService_SetLoadLevelTarget(dev->dimmingService, 
			&UPnPResponseSink_DimmingService_SetLoadLevelTarget, (void *)GET_RESPONSE, (int)newLoadLevel);

	(*env)->ReleaseStringUTFChars(env, jsUDN, udn); 
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeAllOn
 * Signature: ()Ledu/cmu/hcii/puc/devices/UPnP/IntelLight/LightEvent;
 *
 * Sends requests to each currently connected light to turn on
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeAllOn
  (JNIEnv *env, jobject obj)
{
	deviceListEntry *temp = listHead;
	for (; temp != NULL; temp = temp->next)
	{
		if (running && temp->powerService != NULL)
			UPnPInvoke_SwitchPower_SetTarget(temp->powerService, &UPnPResponseSink_SwitchPower_SetTarget, 
				IGNORE_RESPONSE, 1);
	}
}

/*
 * Class:     edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl
 * Method:    nativeAllOff
 * Signature: ()Ledu/cmu/hcii/puc/devices/UPnP/IntelLight/LightEvent;
 *
 * Sends requests to each currently connected light to turn off
 */
JNIEXPORT void JNICALL Java_edu_cmu_hcii_puc_devices_UPnP_IntelLight_LightControl_nativeAllOff
  (JNIEnv *env, jobject obj)
{
	deviceListEntry *temp = listHead;
	for (; temp != NULL; temp = temp->next)
	{
		if (running && temp->powerService != NULL)
			UPnPInvoke_SwitchPower_SetTarget(temp->powerService, &UPnPResponseSink_SwitchPower_SetTarget, 
				IGNORE_RESPONSE, 0);
	}
}

// End Java native implementations
